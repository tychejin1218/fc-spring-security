# 전역 메소드 보안 활성화

## 전역 메소드 보안
혹시 코드에서 `@PreAuthorize` 등의 코드를 본 적이 있는가?
- 이 어노테이션이 어떻게 동작할까?
- 메소드 레벨에서 권한 부여를 구성하는 방법은 어떻게 할 수 있을까?
    - 지금까지는 `abcController`에 위치하는 엔드포인트 수준에 권한 부여를 통해 관리를 했다면,
    - `abcService`, `abcRepository` 등에서는 어떻게 권한 부여를 할 수 있을까?

위 내용을 이해하기 위해서는 **전역 메소드 보안**이라는 것에 대해 알아야 한다.

---

## 전역 메소드 보안으로 할 수 있는 것
크게 두 가지가 있다:
1. **호출 권한 부여**
    - 여러 이용 권리 규칙에 따라 누군가가 메소드를 호출할 수 있는지 확인.
    - 메소드가 실행된 후, 메소드가 반환하는 것에 접근할 수 있는지 확인.

2. **필터링**
    - 메소드가 매개 변수를 통해 받을 수 있는 것(**사전 필터링**)을 결정.
    - 메소드가 실행된 후, 호출자가 메소드에서 다시 받을 수 있는 것(**사후 필터링**)을 결정.

기본적으로 Spring Security에서는 전역 메소드 보안이 **비활성화 상태**로 제공된다.  
따라서, 이 기능을 사용하려면 먼저 활성화해야 한다.

---

## 호출 권한 부여 이해하기
**호출 권한 부여**란 무엇인가?
- 메소드를 호출할 수 있는지 여부를 결정.
- 또한, 메소드를 호출한 후 호출자가 메소드에서 반환된 값에 접근할 수 있는지 여부를 결정하는 규칙을 의미한다.

이때, 메소드에 제공된 파라미터에 따라 접근 가능 여부를 판단하거나, 메소드의 결과에 따라 어떠한 결정을 할 때 이를 활용할 수 있다.

---

## 전역 메소드 보안 활성화
기본적으로 Spring Security에서는 전역 메소드 보안이 **비활성화 상태**로 제공된다.
- 따라서 이 기능을 사용하려면 먼저 **활성화**해야 한다.

전역 메소드 보안을 활성화하면 Spring의 **Aspect**가 하나 활성화된다.
- 이는 권한 부여 규칙을 적용하는 메소드의 호출을 **가로채어**,
  권한 부여 규칙을 바탕으로 가로챈 메소드로 호출을 전달할지 여부를 결정한다.

### 동작 방식
- 전역 메소드 보안이 없을 경우:  
  호출이 컨트롤러에서 서비스로 **바로 전달됨**.

- 전역 메소드 보안이 있을 경우:  
  호출 흐름에 **보안 Aspect**가 추가되어 해당 규칙을 검사함.

- HelloController → 보안 Aspect → HelloService

---

## 호출 권한 부여의 분류
크게 두 가지로 분류된다:
1. **사전 권한 부여 (Pre-Authorization)**
    - 메소드 호출 전에 권한 부여 규칙을 검사하는 방식.

2. **사후 권한 부여 (Post-Authorization)**
    - 메소드 호출 이후에 권한 부여 규칙을 검사하는 방식.

---

## 사전 권한 부여
예를 들어, `findDocumentsByUser(String username)`이라는 메소드가 존재한다고 가정하자.
- 이 메소드는 사용자 이름을 파라미터로 제공하고, 그 결과로 해당 사용자의 문서를 반환한다.
- 호출자는 **인증된 사용자**만 제공해야 해당 메소드가 정상적으로 동작하도록 구현하고 싶다고 하자.
- 인증된 사용자가 아닌 경우, 아예 메소드 호출조차 금지해야 한다.

### 동작 방식
HelloController → 보안 Aspect → HelloService
HelloController는 HelloService를 호출.
보안 Aspect가 요청을 가로채고, 권한 부여 규칙을 검사.
규칙이 충족되지 않으면, 서비스 메소드를 호출하지 않음.
규칙에 충족되지 않으면 예외를 던짐.

---

## 사후 권한 부여에서 주의해야 할 점
**사후 권한 부여**는 메소드가 호출된 **뒤에** 권한 체크를 수행하여, 결과 값을 반환할지 말지를 판단한다.
- 하지만 메소드의 로직에 값 **WRITE** 기능이 포함되어 있다면 **멱등성**을 보장하지 못할 수 있다.  
  즉, 권한이 유효하지 않아 예외가 던져지더라도 메소드 및 데이터 롤백은 별도로 진행되지 않을 수 있다.

### 문제점
- `@Transactional` 어노테이션을 추가하더라도 원하는 대로 동작하지 않을 수 있음.
- 그 이유는, 사후 권한 부여에서 발생하는 예외는 트랜잭션이 **커밋된 이후**에 발생하므로,  
  트랜잭션 매니저가 이를 관리할 수 없기 때문이다.

---

## 프로젝트에서 전역 메소드 보안 활성화
전역 메소드 보안을 활성화하려면 **`@EnableMethodSecurity`** 어노테이션을 추가해야 한다.
- Spring Security 6 이전 버전에서는 **`@EnableGlobalMethodSecurity`** 어노테이션을 사용하면 된다.
```java
@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    // Security-related configuration
}
```
