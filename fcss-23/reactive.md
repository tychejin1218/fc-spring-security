## Reactive 란?

`리액티브 (Reactive)`란 기존의 프로그래밍 흐름과는 다른 방식으로 동작하며, 웹 애플리케이션을 개발할 때 사용할 수 있는 강력한 방법 중 하나입니다. 하지만 모든 상황에 무조건적으로 적용할 수 있는 것은 아니며, 필요한 경우에 적절히 활용하는 것이 중요합니다.

특히, 대규모 작업을 효율적으로 처리해야 하는 경우에 효과적입니다. 일반적인 프로그래밍 방식에서는 작업 종료 시까지 클라이언트가 응답을 기다려야 하지만, 리액티브 프로그래밍에서는 작업을 동시에 나누어 처리하여 더 빠르게 결과를 제공합니다.

이번 시간에는 `리액티브 프로그래밍`을 기반으로 만들어진 애플리케이션에서 Spring Security를 적용하는 방법에 대해 알아보겠습니다. 모든 내용을 다루기에는 방대하므로, 필수 개념 위주로 정리하겠습니다.

---

### 리액티브 앱이란?

앱을 구현할 때 크게 두 가지 방식으로 나눌 수 있습니다.

1. **명령형 방식 (Imperative)**
  - 서버의 엔드포인트를 클라이언트가 호출
  - 모든 데이터를 서버로 전송하며, 클라이언트는 서버의 작업이 완료될 때까지 응답을 기다림

2. **리액티브 방식 (Reactive)**
  - 모든 데이터를 한꺼번에 서버로 보내지 않음
  - 서버는 데이터를 받는 즉시 처리하며, 모든 데이터를 받을 때까지 기다리지 않음

#### 비유: 배달 앱
- **명령형 방식**
  - 모든 주문이 모일 때까지 대기
  - A 매장으로 한 번에 모든 주문을 전달
  - 음식을 한 번에 배달
- **리액티브 방식**
  - 주문 하나만 들어와도 진행
  - A 매장으로 주문 하나를 전달
  - 즉시 배달

---

### 리액티브 스트림 사양

리액티브 스트림은 비동기식 데이터 스트림을 처리하기 위한 표준 방식을 정의하며, 관련 사양은 [Reactive Streams](https://www.reactive-streams.org/)에서 확인할 수 있습니다.

#### 프로젝트 리액터 (Project Reactor)
리액티브 스트림 사양 기반으로 개발된 프레임워크로, 리액티브 스트림을 구성할 수 있는 함수형 API를 제공합니다.

- 리액티브 애플리케이션에서는 `Publisher`와 `Subscriber`가 중심 역할을 합니다.
  - `Publisher<<Interface>>`: 값을 생성
  - `Subscriber<<Interface>>`: 값을 구독 (리액티브 스트림에는 최소 1개의 Subscriber 필수)

#### 프로젝트 리액터의 주요 구성 요소
- **Mono**: 0개 또는 1개의 값을 갖는 스트림을 나타내는 Publisher 구현체
- **Flux**: 0개 이상의 값을 갖는 스트림을 나타내는 Publisher 구현체

---

### 리액티브 애플리케이션 시작하기

리액티브 기반의 스프링부트 애플리케이션을 빌드하려면 아래와 같이 `build.gradle` 파일에 WebFlux 의존성을 추가합니다.

```gradle
implementation 'org.springframework.boot:spring-boot-starter-webflux'
```

#### HelloController 작성
리액티브 기반으로 간단한 애플리케이션을 작성하여 시작할 수 있습니다.

---

### 리액티브 애플리케이션의 특징

1. 리액티브 기반 스프링부트 애플리케이션은 `톰캣 (Tomcat)` 서버가 아닌 **네티 (Netty)** 서버 기반으로 동작합니다.
  - 기존 톰캣 기반과는 차이가 있음
2. 비-리액티브 방식의 엔드포인트와 동일하게 작동
  - 명령형 방식처럼 `curl http://localhost:8080/hello` 호출 가능

---

### 리액티브와 스프링 시큐리티

리액티브 프로그래밍이 적용된 애플리케이션에서는 Spring Security의 작동 방식에 차이가 생깁니다.

- 리액티브는 작업 처리를 위해 **여러 스레드**를 사용
- 기존 명령형 방식 웹에서는 요청당 한 스레드를 할당 (ThreadLocal 활용)
- 리액티브에서는 여러 스레드 사용으로 인해 기존 `SecurityContext` 구현이 영향을 받음
- 따라서, 권한 부여 구성 및 사용자 인증 정보 검색을 담당하는 `UserDetailsService`도 리액티브 방식을 지원해야 함

---

### 보안 컨텍스트와 리액티브

- **비-리액티브** 방식
  - 한 요청당 하나의 스레드가 할당
  - 스레드별로 `SecurityContext`를 관리
- **리액티브** 방식
  - 한 요청이 여러 스레드에 의해 처리 가능
  - 기존 `ThreadLocal` 방식이 아닌 적합한 방식으로 `SecurityContext` 관리 필요
